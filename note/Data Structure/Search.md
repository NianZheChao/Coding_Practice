# 查找算法

## 基本概念

- 关键字(key word)
  - 数据元素种的一个数据项，可以标识数据元素
  - 主关键字、次关键字（关键字的唯一性）
- 查找表
  - 具有同一属性的数据元素的集合
  - 分为静态查找表和动态查找表两类
- 查找
  - 给定关键字值K，在表中找出关键字等于给定值K的结点

```c
typedef struct{
    KeyType key;  //关键字字段
        ...       //其他字段
}ElemType
```

- 平均查找长度ASL(Average Search Length)
  - 为确定记录在表中的位置，需和给定值进行比较的关键字的个数的期望值
  - 对含有n个记录的表，$ASL=\sum\limits_{i=1}^n{p_ic_i}$
  - 其中$p_i$为查找表中第$i$个元素的概率，$\sum\limits_{i=1}^n{p_i} = 1$，$c_i$为找到表中第$i$个元素所需比较次数

## 静态查找

静态查找问题：在查找过程中数据是不变的

静态查找表结构：顺序表、线性链表

### 顺序查找

#### 思想

从表的一端开始，逐个进行记录的关键字和给定值的比较。

**监视哨**：在顺序表的0位置放置为所查找的关键字，从尾部往前查找，查找不会报错，至多在第一个元素返回，也无需比较**正在比较元素的编号与顺序表总长度**，使比较次数减半。

#### 分析

- 优点
  - 算法简单
  - 顺序表或链表均适用
  - 结点是否按关键字有序都适用
- 缺点
  - 查找效率低
- 合理安排节点位置，使访问越频繁的数据比较的次数越少
- 查找成功是，ASL约为元素个数的一半

### 折半查找（二分查找）

#### 思想

表中元素按关键字有序排列，在顺序表list中查询值为k的元素的位置。

```c
step1:初始化查找区间的下界low、上界high
step2:如查找区间上下界重叠，则查找失败，否则step3
	  if(low>high)
    	  return FALSE;
step3:mid = floor((low+high)/2)  //向下取整，小数部分截断
step4:if(k==list.data[mid])
    	  return mid;
	  else 调整查找区间，转step2
```

二分查找可用二叉树来描述

- 已知表中有n个结点
- 以当前查找区间的中点为根
- 左、右半区的结点分别作为根的左右子树
- 得到的二叉树，称为二分查找判定树(Decision Tree)或比较树(Comparison Tree)
- ASL:$O(log_2n)$

#### 分析

- 查找效率高，但表需按关键字有序
- 适用于表结点比较稳定的、很少做插入或删除操作的顺序表
- 不适用于链表

### 分块查找（索引顺序查找）

#### 思想

##### 查找过程

表元素分成几块，块内无序，块间有序；先确定待查记录所在块，再在块内查找。

##### 适用条件

后一个子表中，所有记录的关键字均大于前一个子表中的最大关键字。

##### 算法思路

存储待查数据元素，每个元素包含关键字域；**建立索引表，每个索引表结点含有最大关键字域和指向本块第一个结点的指针。**

##### 算法描述

```C
//分块查找：在表list（索引表为idtable）中查询值为k（主关键字）的元素的位置
step1：查找idtable，定位k所处的块；idtable是有序表，可使用二分查找或顺序查找
step2：若找不到索引块，return FALSE，否则进入step3
step3：在确定的块中顺序查找k，如找到则return pos，否则return -1；
```

#### 分析

分块查找表由“分块有序”的数据表和索引表组成。

- 块间有序，块内无序
- 索引表有序
- 多选用顺序存储（方便使用二分查找）
- 分块查找的效率介于顺序查找与二分查找之间

分块查找是两次查找过程，其ASL是两次查找的ASL之和。

设b：块数；s：块中结点个数；

如以二分查找确定块：
$$
ASL_{blk}=ASL_{bn}+ASL_{sq}≈log_2(b)+\frac{b+1}{2}≈log_2{\frac{n}{s}+\frac{s}{2}}
$$
如以顺序查找确定块：
$$
ASL_{blks}=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}
$$
**当$s=\sqrt{n}$时，$ASL_{blks}$取极小值$1+\sqrt{n}$**

## 动态查找

### 二叉排序树（Binary Sort Tree,BST）

#### 思想

##### 二叉排序树定义

二叉排序树也称二叉搜索树，其或者是一棵空树，或者满足以下性质：若左子树不空，则左子树上所有结点的值均小于根结点的值；若右子树不空，则右子树上所有结点的值均大于根结点的值。

按照中序遍历该树得到的序列是递增有序的。

##### 二叉排序树生成

从空树出发，经过一系列插入操作后，生成一棵二叉排序树。

插入操作：若二叉树为空，则插入的结点应为新的根结点；否则在其左、右子树上查找，直至某个节点的左子树或右子树为空为止，则插入结点应为该结点的左孩子或右孩子。

##### 查找的算法描述

```c
在以t为根的二叉排序树t上查找指定的值kx
step1：若t为空，return FALSE,否则进入step2
step2：将kx与根节点t的关键字比较，若相等，return t，否则进入step3
step3：转入子树进行查找
	如kx小于t的关键字，进入以t为根节点的左子树，然后转step1
	如kx大于t的关键字，进入以t为根节点的右子树，然后转step1
```

#### 分析

- ASL与二叉树的形态有关
- BST是把表的n个结点依次插入生成的

- 最坏情况下：BST是深度为n的单支树，其ASL与顺序查找相同，$ASL = \frac{n+1}{2}$
- 最好情况下：BST形态比较匀称，得到与二分查找判定树形态相似的BST，$ASL=log_2n$，插入、删除、查找算法的时间复杂度均为$O(log_2n)$



## 哈希表(Hash Table)

### 背景

二分查找、顺序查找等，都以关键字的比较作为查找基础，如果建立关键字与存储地址的映射关系，则已知关键字时，可直接定位到相应的存储位置。理想情况下，无须任何比较就可以找到待查关键字，期望时间为O(1)。

如有关键字集合{18,27,1,20,22,6,10,13,41,15,25\}​，且有位置与元素的关系函数：h(key)=key mod 11，则可用一次计算找到各个元素的位置。

### 概念

哈希表是一种存储结构，以结点的关键字K为自变量，通过一个函数关系h，计算函数值h(K)，把h(K)解释为结点的存储地址，将结点存入存储位置h(K)，由此构成的表称为哈希表，散列表，或杂凑表，又称哈希方法、散列方法、关键字-地址转换法、杂凑法。其中函数h称为**散列函数**，h(K)称为**散列地址**。

**哈希表查找**时，根据待查找的关键字Q，用函数h计算h(Q)，再到存储位置h(Q)去取Q

两个不同的关键字可能得到相同的散列值，被映射到表的同一位置，称为冲突(Collision)或碰撞，两个发生冲突的关键字称为该散列函数的**同义词**。安全避免冲突的策略可以是选择更合适的散列函数，或使关键字的个数小于或等于散列表的长度。

### 设计思想

若关键字个数大于散列表的长度，则无论怎样设计h，也不可能避免冲突。此时设计散列函数的思路：(1)尽可能使冲突最少；(2)需确定解决冲突的方法：使发生冲突的同义词能够存储到散列表中。

- 影响冲突的因素：
  - 与h相关
  - 与表的填满程度相关
  - 设m表示散列表的表长，n表示表中填入的结点个数，将散列表的装填因子定义为：a = n/m，a越大，表越满，冲突的机会就越大。通常取a<=1

### 常用哈希函数

#### 平方取中法

#### 随机数法

#### 除留余数法

### 处理冲突的方法

#### 开放定址法

##### 思想

将一个关键字添加到散列表中时若发生冲突，则使用某种探测技术在散列表中形成一个探测序列，沿此序列逐个单元查找，直到找到下一个开放的地址为止。只要散列表足够大，总能找到开放的地址，再将关键字添加到该位置。

##### 算法

- 探测技术

将散列表T[0...m-1]看成是一个循环向量，若初始探查的地址为d，则最长的探查序列为：d,d+1,d+2,...,m-1,0,1,...,d-1；探查时从地址d开始，首先探查T[d]，然后依次探查T[d+1]，...，直到T[m-1]，此后又循环到T[0]，T[1]，直到探查到T[d-1]为止。

- 堆积现象

散列地址不同的关键字，争夺同一个后继位置，使得非同义词也加入了探测序列；这样增加了探查的长度，即增加了查找时间。若散列函数不好或装填因子过大，会使堆积加剧。【装填因子在0.7-0.8之间为较好】

#### 拉链法

##### 思想

设哈希地址域在区间[0,m-1]上，以每个哈希地址作为一个指针，指向一个链，即建立m个空链表，由哈希函数对应关键字转换后，映射到同一哈希地址i的同义词，均加入到对应的链表中。

##### 分析

- 优点
  - 处理冲突简单，无堆积现象，非同义词不会发生冲突，ASL较短
  - 链表上节点空间动态申请，适合建表前无法确定表长的情况
  - 开放定址法所要求的装填因子需要小，其结点规模较大时会浪费很多空间；而拉链法可取装填因子>=1，且结点密度较大时，其增加的指针域可忽略不计，空间效率较好
  - 拉链法构造的散列表中，删除结点的操作易于实现

- 缺点
  - 指针需要额外的空间
  - 当结点规模较小时，开放定址法较为节省空间
  - 若将节省的指针空间来扩大散列表的规模，可使装填因子变小，减少开放定址法的冲突，从而提高ASL

### 哈希表的查找效率分析

- 哈希表的查找过程基本上和造表过程相同
- 一些关键字可通过哈希函数转换的地址直接找到，另一些关键字通过哈希函数得到的地址产生冲突，需要按处理冲突的方法进行查找；常见的冲突后的查找仍然是将待查找的值key与关键字进行比较
- 对哈希表的查找效率度，用ASL衡量
- 影响产生冲突多少有以下三个因素
  - 哈希函数是否均匀
  - 处理冲突的方法
  - 哈希表的装填因子
- 查找时，关键字的比较次数，取决于产生冲突的多少；影响产生冲突多少的因素，也就是影响查找效率的因素。