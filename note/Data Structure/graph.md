# 图

## 概念

### 图

$G = (V,E)$

$V$是非空有限集合，其元素称为顶点；$E$是边的集合；顶点偶对称为边

### 有向图

有序的顶点偶对：$<x,y>$

$G_1=(V_1,E_1)$，其中：$V_1=\{v_1,v_2,v_3,v_4\}$，$E_1=\{<v_1,v_2>, <v_1,v_4>,<v_3,v_1>,<v_4,v_3>\}$ //表示了弧头和弧尾

### 无向图

无序的顶点偶对$(x,y)$

$G_2=(V_2,E_2)$，其中：$V_2=\{v_1,v_2,v_3,v_4,v_5\}$，$E_2=\{(v_1,v_2),(v_1v_4),(v_2,v_3),(v_2,v_5),(v_3,v_4),(v_3,v_5),\}$

### 完全图(completed graph)

有$\frac{n(n-1)}{2}$条边的无向图称为完全图。

有$n(n-1)$条边的有向图称为完全图。

### 邻接点

### 子图

### 路径

**简单路径**：顶点不重复出现的路径

**回路**：第一个顶点和最后一个顶点相同的路径

**简单回路**：除第一顶点和最后一个顶点外，其余顶点不重复出现的回路

**权(weight)**：在图的每条边上加数字作权

**网(network)**：带权的图称为网

### 连通

**连通图**：如果图中任意两个顶点都是连通的，则是连通图

**连通分量**：无向图的极大连通子图；连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量

**强连通图**：有向图中，每一对顶点之间都存在路径，则称其为强连通图

**强连通分量**：有向图的极大强连通子图称为强连通分量；强连通图的强连通分量是其自身；非强连通的有向图可能有多个强连通分量

**生成树**：一个连通图的极小连通子图；含有图中全部n个顶点，但只有能令图连通的$n-1$条边

## 存储

### 邻接矩阵

#### 概念

表示顶点间邻接关系的矩阵。

无向图的邻接矩阵是对称的，可压缩存储；有n个顶点的无向图需要$\frac{n(n+1)}{2}$的存储空间。

有向图的邻接矩阵不一定对称，需要$n^2$的存储空间。

无向图顶点$v_i$的度为邻接矩阵第$i$行元素之和。

有向图中顶点$v_i$的出度为邻接矩阵第$i$行元素之和，入度为邻接矩阵第$i$列元素之和。

#### 类型定义

```C
#define NMAX 100  //图的顶点数
typedef int datatype;
typedef struct{
    datatype vexes[NMAX+1];  //顶点集
    int edges[NMAX+1][NMAX+1];  //邻接矩阵
    int n,e;  //顶点数和边数
}graph;
graph *ga;
```

### 邻接表

#### 概念

**顶点表**：每个顶点的指针域指向边表的第一个结点；数据域存储顶点信息；顶点表结点，相当于边表头结点。

**边表**：把同一顶点发出的边链接在一起，每个结点代表一条边；边表结点保存着与某顶点关联的另一顶点，和指向下一表结点的指针。

#### 类型定义

```C
#define NMAX 100   //顶点的最大数

typedef struct node{   //边表结点
    int vertex;      //编号
    struct node *next;
}edgenode;

typedef struct{   //顶点表结点
    vertype data;
    edgenode *head;  //边表头指针
}vernode;

typedef struct{  //图的定义
    vernode vexes[NMAX+1];  //顶点表
    int n,e;   //顶点数，边数
}graph;
graph *ga;
```

### 十字链表(orthogonal list)

#### 概念

- 将有向图的邻接表和逆邻接表结合
- 弧头相同的弧在同一链表上，弧尾相同的弧也在同一链表上
- 顶点表结点由三个域组成
  - data：存储与顶点相关的信息
  - firstin：指向以顶点为弧头的第一个弧结点
  - firstout：指向以顶点为弧尾的第一个弧结点
- 边表（弧）结点由四个域组成
  - 尾域(tailvex)：指示弧尾顶点
  - 头域(headvex)：指示弧头顶点
  - 链域(hlink)：指向弧头相同的下一条弧
  - 链域(tlink)：指向弧尾相同的下一条弧

#### 类型定义

```C
//边表结点
typedef struct arctype{
    int tailvex,headvex;
    struct arctype *hlink,*tlink;
}arclink

//顶点表结点
typedef struct vnode{
	vertex data;
	arclink *firstin,*firstout;
}ortholistNode;

ortholistNode graph[NMAX];
```

### 边集数组

#### 概念

- 用数组存储图中所有边
  - 存储边的起点、终点和权
  - 对无向图，可选边的任一端为起点
- 边在数组中的次序可任意，也可视具体要求而定
- 边集数组只存储边的信息，还需顶点表存储顶点信息

#### 类型定义

```C
typedef struct{
    int fromvex;   //边的起点
    int endvex;    //边的终点
    int weight;    //边的权值
}EDGE;

EDGE edgeset[MaxEdgeNum];
```

适合对边依次进行处理的运算，不适合对顶点的运算和对任一条边的运算。

## 遍历

### 深度优先遍历(Depth First Search)

#### 算法

```c
//递归算法DFS(graph *ga,int vi)
//假设图ga有n个顶点，用邻接矩阵存储ga，初始顶点vi
for k in (1~n)
    visited[i] = 0;
DFS(ga,vi){
    visit(vi); //访问顶点vi
    visited[vi] = 1;
    for k in (1~n){
        if(fa->edges[vi][k]==1&&!visited[k])
            DFS(ga,k);
    }
}
```

```C
//假设图ga有n个结点，用邻接表存储ga
for k in(1~n)
    visited[i] = 0;
DFS(ga,vi){
    visit(vi);//访问顶点vi
    visited[vi] = 1;
    p = (ga->vexes[vi]).head;
    while(p){           //访问vi的边表的所有结点
        if(!visited[p->vertex])
            DFS(ga,p->vertex);
        p = p->next;
    }
}
```

### 广度优先遍历(Breadth First Search)

#### 概念

BFS算法：类似于树的层次遍历

- 假设初始时图中所有顶点都没被访问过
  - 从图中某一顶点vi出发，访问vi
  - 访问vi的全部邻接点w1,w2,...,wt
  - 再从这些被访问的顶点出发，逐次访问它们的邻接点（已被访问的顶点除外）
  - 以此类推，直到所有顶点都被访问为止
- 需要辅助数组visited[1...n]，记录各结点被访问的状态

### 图的连通性

- 连通图，从图中任一顶点出发，便可遍历图
- 非连通图，从任一顶点出发，不能访问所有顶点，只能访问一个连通分量
- 求图的连通分量？
  - 从图中任一顶点vi出发遍历图
  - 遍历中被访问的顶点，都在与vi的连通分量上
  - 一次遍历结束，若还有未被访问过的顶点，则从其中任一顶点出发，重新遍历图，可求得另一个连通分量
- 若DFS（BFS）算法仅被调用一次，则图是连通图
- 若被调用多次，则图是非连通图，得到多个连通分量

算法：

```C
step1:for(i:1~n)
    	visited[i] = FALSE;
step2:for(i:1~n)
    	if(!visited[i])
            DFS(ga,i);
```

## 图的拓扑排序

### 概念

#### 有向无环图

**无环图**(Directed Acycline Graph)：无环（回路）的有向图叫做有向无环图。

**顶点表示活动的网** Activity On Vertex Network,AOV Network：

- 顶点表示活动，弧表示活动间的先后关系
- AOV网中不能有回路，回路意味着某项活动以自己为先决条件，形成死锁

#### 拓扑排序

- 把AOV网中各顶点按其活动的先后关系，排列成一个线性序列的过程
- 一个AOV网的拓扑序列不是唯一的

#### 图的拓扑排序

- AOV网用邻接表存储
- 在邻接表的表头结点增加存放顶点入度的域
- 栈或队列存放入度为0的顶点

算法思路：

```C
step1:初始化栈，令count = 0
step2:创建ga的邻接表，初始化每个顶点的入度为0
step3:将当前可开始的活动入栈
	foreach k in 1~n
		if(ga->vexex[k].indegree==0)
            push(stack,k)
step4:while(!empty(stack))
    	vi=pop(stack)
    	visit(vi),count++
    	将后续活动的入度-1，并记录新的可开始的活动
    		p = ga->vexex[vi].head
    		while(p)
                ga->vexex[p->data].indegree--
                if(ga->vexex[p->data].indegree == 0)
                    push(stack,p->data)
                p = p->next
step5:如仍有活动未进行，return FALSE,否则return true
    	if(count<n)
            return FALSE
```

## 最小生成树

### 概念

#### 生成树

**连通图**G的极小连通子图，称为图的生成树；包含图中所有顶点；无回路；

生成树包含n个顶点，只有n-1条边，任意去掉一条边，图将变成非连通图，添加一条边，图中将出现回路；含n个顶点n-1条边的图不一定是生成树

对连通图G=(V,E)，从G中任一顶点出发遍历，得到一个边集T(G)，T(G)与V构成图G的极小连通子图，即图G的一颗生成树。

由DFS得到**深度优先生成树**，由BFS得到**广度优先生成树**

对于**非连通图**，每个连通分量的顶点集和遍历时的边构成一棵生成树；全部连通分量的生成树构成生成森林

#### 最小生成树

图的生成树不是唯一的，从不同的顶点出发，可得到不同的生成树。

**最小生成树(Minimum Spanning Tree)**：

连通网络G=(V,E)的各边带权，因此其生成树各边带权。生成树的权即为生成树各边的权值之和，最小生成树即为权值最小的生成树。

### Prim算法

算法思路：

从某一顶点出发，将相邻的所有边中权值最小的加入树中。

```
step1:初始化MST的顶点集U，中含一个顶点u0
step2:初始化MST的边集E为空
step3:初始化候选边集C = {(u0,v)}(v∈V-U)
step4:numv = 0
step5:从候选边集C中选中一条最短边加入MST，随该边引入顶点ui，并更新候选边集C
	while(numv<n){
		从C中选最短边(u',v');
		将边(u',v')并入集合E;
		将v'并入集合U
		numv = numv + 1
		调整候选边集C{
			取最小的(n-numv)条边构成C
			其中∀(u,v)∈C:u∈U,v∈V-U,(u,v)∉E
		}
	}
step6:return
```

### Kruskal算法

算法思路：在所有顶点中，寻找（相邻的权值最小的边&&两顶点不在同一个连通分量上），将该边加入树中。//并查集

```C
step1:设N-(V,E)是连通网络，T=(U,E')是正在构造的生成树
step2:令T的初始状态为
		有n个顶点、无边的非连通图T=(V,Φ);图中每个顶点自成一个连通分量
step3:在E中选择权值最小的边(u',v')
		若边(u',v')依附的顶点u'、v'落在T的不同连通分量上，则将(u',v')加入E'{
			边(u',v')使顶点u'、v'所处的两个连通分量合成一个连通分量
		}
		否则选择下一条代价最小的边
step4:重复step3，直到T中所有顶点在同一连通分量上
```

