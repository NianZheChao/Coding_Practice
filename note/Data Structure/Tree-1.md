## 树

客观世界中许多事物存在层次关系；分层次组织在管理上具有更高的效率。

### 引子：查找

查找：给定某个给定关键字K，从集合R中找出关键字与K相同的记录

静态查找：集合中的记录是固定的；动态查找：集合中记录是动态变化的（除查找还可能发生插入和删除）。

#### 静态查找的方法

- 顺序查找

  ```c
  int SequentialSearch(List Tbl ,ElementType K){
      int i;
      Tbl->Element[0] = K;                              //建立哨兵
      for(i = Tbl->Length; i>0 && Tbl->Element[i] != K; i--);
      return i;
  }
  ```

-  二分查找（Binary Search）

  要求：N个数据元素的关键字有序存放在一个数组里

  ```c
  int BinarySearch(List Tbl ,ElementType K){
      int left,right,mid,NoFound = -1;
      
      left = 1;
      right = Tbl -> Length;
      while(left <= right){
          mid = (left + right)/2;
          if(K < Tbl -> Element[mid])
              right = mid - 1;                   //调整右边界
          else if(K > Tbl -> ELement[mid])
              left = mid + 1;                    //调整左边界
          else
              return mid;
      }
      return NotFound;
  }
  
  //T=O(logN)
  ```

### 树的定义

树（Tree）：$n(n>=0)$个结点构成的有限集合。当$n=0$时，称为空树；对于任一棵非空树（$n>0$），它具备以下性质：

- 树中有一个称为根（root）的特殊结点，用"r"表示；
- 其余结点可分为m个互不相交的有限集$T_1,T_2,...，T_m$，其余每个集合本身又是一棵树，称为原来树的“子树（SubTree）”

树的基本术语：

- 结点的度（Degree）：结点的子树个数。
- 树的度：树的所有结点中最大的度数。
- 叶结点：度为0的结点。
- 父结点：有子树的结点是其子树的根结点的父结点。

### 二叉树的性质

#### 普通二叉树

在二叉树的第$i$层上至多有$2^{i-1}$个结点。$(i>=1)$

深度为$K$的二叉树，至多有$2^{k-1}$个结点。$(k>=1)$

对于任意二叉树，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。

#### 满二叉树

深度为$K$的满二叉树，有$2^{K-1}$个结点。

#### 完全二叉树

对于任意结点，若其右子树的深度为$L$，则其左子树的深度必为$L$或$L+1$。

具有$n$个结点的完全二叉树的深度为$[log_2n] +1$（log向下取整）。

对于有$n$个结点的完全二叉树的结点按层序编号，则对任一结点$i$，有

- 如果$2i>n$，则结点无左孩子，否则其左孩子是结点$2i$。
- 如果$2i+1>n$，则结点无右孩子，否则其右孩子是结点$2i+1$。

### 树、森林和二叉树

#### 孩子兄弟表示法

将树转换为二叉树：对于一个结点，左指针指向它的第一个孩子，右指针指向它的右兄弟。

将二叉树转换成树：对于任意一个结点，左子树转换成它的子树；如果是根节点，右子树转换成另一棵树，如果不是，右子树转换为该结点的兄弟。

#### 森林 - 二叉树

对于任意一个结点，左指针指向它的第一个孩子，右指针指向它的兄弟/旁边的树。

对树做**先根序遍历**时，所得序列与其对应的二叉树的**先序遍历序列**一致；对树做**后根序遍历**时，所得序列与其所对应的二叉树的**中序遍历序列**一致。

### 哈夫曼树

#### 引子

树的路径长度：从树根到树中的每个结点的路径长度之和。

结点数相同时，完全二叉树的路径长度最短。

#### 概念

**结点的权**：给树的结点赋以一定意义的数值，称为该结点的权。

**带权路径长度**：路径长度 * 该结点的权

**哈夫曼树**：由n个带权叶子结点构成的二叉树具有不同形态，其中WPL(Weighted Path Length of Tree)最小的二叉树，称为哈夫曼树，又叫最优二叉树，或最佳判定树。

#### 创建哈夫曼树

- 初始化：根据给定的n个权值{w1,w2,...,wn}，构造n棵只有根节点的二叉树，令其权值分别为wj
- 合并
  - 在森林中选取根节点权值最小、次小的两棵树p1,p2。
  - 分别以p1,p2作为左右子树，构造一棵新的二叉树tk
    - 置tk的权值为其左右子树根节点权值之和
    - 置tk为其左右子树的双亲
    - 分别置p1,p2为tk的左右孩子
  - 从森林中删除p1,p2，并将新得到的二叉树tk加入森林中
- 重复合并步骤，直到森林中只含一棵树为止

哈夫曼树中结点总数为 $2n-1$。

哈夫曼树形态不是唯一的。（树中结点权值可能相同）

#### 哈夫曼算法分析

```C
#define n 叶子数
#define m 2*n-1     //n个叶子结点的哈夫曼树，共有2n-1个结点
tepedef struct node{
    int weight;
    int parent,lchild,rchild;   //每个结点都要存储其双亲和孩子的信息
}hufmtree;
hufmtree forest[m+1];
//用顺序表存储哈夫曼树
```

