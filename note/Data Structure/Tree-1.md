## 树

客观世界中许多事物存在层次关系；分层次组织在管理上具有更高的效率。

### 引子：查找

查找：给定某个给定关键字K，从集合R中找出关键字与K相同的记录

静态查找：集合中的记录是固定的；动态查找：集合中记录是动态变化的（除查找还可能发生插入和删除）。

#### 静态查找的方法

- 顺序查找

  ```c
  int SequentialSearch(List Tbl ,ElementType K){
      int i;
      Tbl->Element[0] = K;                              //建立哨兵
      for(i = Tbl->Length; i>0 && Tbl->Element[i] != K; i--);
      return i;
  }
  ```

-  二分查找（Binary Search）

  要求：N个数据元素的关键字有序存放在一个数组里

  ```c
  int BinarySearch(List Tbl ,ElementType K){
      int left,right,mid,NoFound = -1;
      
      left = 1;
      right = Tbl -> Length;
      while(left <= right){
          mid = (left + right)/2;
          if(K < Tbl -> Element[mid])
              right = mid - 1;                   //调整右边界
          else if(K > Tbl -> ELement[mid])
              left = mid + 1;                    //调整左边界
          else
              return mid;
      }
      return NotFound;
  }
  
  //T=O(logN)
  ```

### 树的定义

树（Tree）：$n(n>=0)$个结点构成的有限集合。当$n=0$时，称为空树；对于任一棵非空树（$n>0$），它具备以下性质：

- 树中有一个称为根（root）的特殊结点，用"r"表示；
- 其余结点可分为m个互不相交的有限集$T_1,T_2,...，T_m$，其余每个集合本身又是一棵树，称为原来树的“子树（SubTree）”

树的基本术语：

- 结点的度（Degree）：结点的子树个数。
- 树的度：树的所有结点中最大的度数。
- 叶结点：度为0的结点。
- 父结点：有子树的结点是其子树的根结点的父结点。

### 二叉树的性质

在二叉树的第$i$层上至多有$2^{i-1}$个结点。$(i>=1)$

深度为$K$的二叉树，至多有$2^{k-1}$个结点。$(k>=1)$

对于任意二叉树，如果其终端结点数为$n_0$，度为2的结点数为$n_2$，则$n_0=n_2+1$。

#### 满二叉树

深度为$K$的满二叉树，有$2^{K-1}$个结点。

#### 完全二叉树

对于任意结点，若其右子树的深度为$L$，则其左子树的深度必为$L$或$L+1$。

具有$n$个结点的完全二叉树的深度为$[log_2n] +1$（log向下取整）。

对于有$n$个结点的完全二叉树的结点按层序编号，则对任一结点$i$，有

- 如果$2i>n$，则结点无左孩子，否则其左孩子是结点$2i$。
- 如果$2i+1>n$，则结点无右孩子，否则其右孩子是结点$2i+1$。

### 树、森林和二叉树

#### 孩子兄弟表示法

将树转换为二叉树：对于一个结点，左指针指向它的第一个孩子，右指针指向它的右兄弟。

将二叉树转换成树：对于任意一个结点，左子树转换成它的子树；如果是根节点，右子树转换成另一棵树，如果不是，右子树转换为该结点的兄弟。

#### 森林 - 二叉树

对于任意一个结点，左指针指向它的第一个孩子，右指针指向它的兄弟/旁边的树。

对树做**先根序遍历**时，所得序列与其对应的二叉树的**先序遍历序列**一致；对树做**后根序遍历**时，所得序列与其所对应的二叉树的**中序遍历序列**一致。

### 哈夫曼树

